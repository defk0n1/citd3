{
  "version": 3,
  "sources": ["../../split-type/dist/index.js"],
  "sourcesContent": ["/**\r\n * SplitType\r\n * https://github.com/lukePeavey/SplitType\r\n * @version 0.3.4\r\n * @author Luke Peavey <lwpeavey@gmail.com>\r\n */\r\n\r\n// Polyfill the following DOM methods that are not supported in IE 11.\r\n\r\n(function () {\r\n  function append() {\r\n    var length = arguments.length;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      var node = i < 0 || arguments.length <= i ? undefined : arguments[i];\r\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\r\n    }\r\n  }\r\n\r\n  function replaceChildren() {\r\n    while (this.lastChild) {\r\n      this.removeChild(this.lastChild);\r\n    }\r\n\r\n    if (arguments.length) this.append.apply(this, arguments);\r\n  }\r\n\r\n  function replaceWith() {\r\n    var parent = this.parentNode;\r\n\r\n    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      nodes[_key] = arguments[_key];\r\n    }\r\n\r\n    var i = nodes.length;\r\n    if (!parent) return;\r\n    if (!i) parent.removeChild(this);\r\n\r\n    while (i--) {\r\n      var node = nodes[i];\r\n\r\n      if (typeof node !== 'object') {\r\n        node = this.ownerDocument.createTextNode(node);\r\n      } else if (node.parentNode) {\r\n        node.parentNode.removeChild(node);\r\n      }\r\n\r\n      if (!i) {\r\n        parent.replaceChild(node, this);\r\n      } else {\r\n        parent.insertBefore(this.previousSibling, node);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (typeof Element !== 'undefined') {\r\n    if (!Element.prototype.append) {\r\n      Element.prototype.append = append;\r\n      DocumentFragment.prototype.append = append;\r\n    }\r\n\r\n    if (!Element.prototype.replaceChildren) {\r\n      Element.prototype.replaceChildren = replaceChildren;\r\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\r\n    }\r\n\r\n    if (!Element.prototype.replaceWith) {\r\n      Element.prototype.replaceWith = replaceWith;\r\n      DocumentFragment.prototype.replaceWith = replaceWith;\r\n    }\r\n  }\r\n})();\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if (\"value\" in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  return Constructor;\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, {\r\n      value: value,\r\n      enumerable: true,\r\n      configurable: true,\r\n      writable: true\r\n    });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nfunction ownKeys(object, enumerableOnly) {\r\n  var keys = Object.keys(object);\r\n\r\n  if (Object.getOwnPropertySymbols) {\r\n    var symbols = Object.getOwnPropertySymbols(object);\r\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\r\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\r\n    });\r\n    keys.push.apply(keys, symbols);\r\n  }\r\n\r\n  return keys;\r\n}\r\n\r\nfunction _objectSpread2(target) {\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    var source = arguments[i] != null ? arguments[i] : {};\r\n\r\n    if (i % 2) {\r\n      ownKeys(Object(source), true).forEach(function (key) {\r\n        _defineProperty(target, key, source[key]);\r\n      });\r\n    } else if (Object.getOwnPropertyDescriptors) {\r\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n    } else {\r\n      ownKeys(Object(source)).forEach(function (key) {\r\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\r\n      });\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction _slicedToArray(arr, i) {\r\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\r\n}\r\n\r\nfunction _toConsumableArray(arr) {\r\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\r\n}\r\n\r\nfunction _arrayWithoutHoles(arr) {\r\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\r\n}\r\n\r\nfunction _arrayWithHoles(arr) {\r\n  if (Array.isArray(arr)) return arr;\r\n}\r\n\r\nfunction _iterableToArray(iter) {\r\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\r\n}\r\n\r\nfunction _iterableToArrayLimit(arr, i) {\r\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\r\n  var _arr = [];\r\n  var _n = true;\r\n  var _d = false;\r\n  var _e = undefined;\r\n\r\n  try {\r\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\r\n      _arr.push(_s.value);\r\n\r\n      if (i && _arr.length === i) break;\r\n    }\r\n  } catch (err) {\r\n    _d = true;\r\n    _e = err;\r\n  } finally {\r\n    try {\r\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\r\n    } finally {\r\n      if (_d) throw _e;\r\n    }\r\n  }\r\n\r\n  return _arr;\r\n}\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) {\r\n  if (!o) return;\r\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\r\n  var n = Object.prototype.toString.call(o).slice(8, -1);\r\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\r\n}\r\n\r\nfunction _arrayLikeToArray(arr, len) {\r\n  if (len == null || len > arr.length) len = arr.length;\r\n\r\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\r\n\r\n  return arr2;\r\n}\r\n\r\nfunction _nonIterableSpread() {\r\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n}\r\n\r\nfunction _nonIterableRest() {\r\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n}\r\n\r\n/**\r\n * Shallow merges the properties of an object with the target object. Only\r\n * includes properties that exist on the target object. Non-writable properties\r\n * on the target object will not be over-written.\r\n *\r\n * @param {Object} target\r\n * @param {Object} object\r\n */\r\nfunction extend(target, object) {\r\n  return Object.getOwnPropertyNames(Object(target)).reduce(function (extended, key) {\r\n    var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\r\n    var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\r\n    return Object.defineProperty(extended, key, newValue || currentValue);\r\n  }, {});\r\n}\r\n\r\n/**\r\n * Checks if given value is a string\r\n *\r\n * @param {any} value\r\n * @return {boolean} `true` if `value` is a string, else `false`\r\n */\r\nfunction isString(value) {\r\n  return typeof value === 'string';\r\n}\r\n\r\nfunction isArray(value) {\r\n  return Array.isArray(value);\r\n}\r\n\r\n/**\r\n * Parses user supplied settings objects.\r\n */\r\n\r\nfunction parseSettings() {\r\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  var object = extend(settings); // `split` may be used as an alias for the `types` option\r\n  // Parse the `types` settings into an array of valid split types.\r\n  // If `types` is explicitly set to an empty string or array, text will not be\r\n  // split at all.\r\n\r\n  var types;\r\n\r\n  if (object.types !== undefined) {\r\n    types = object.types;\r\n  } else if (object.split !== undefined) {\r\n    types = object.split;\r\n  }\r\n\r\n  if (types !== undefined) {\r\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(function (type) {\r\n      return String(type).trim();\r\n    }).filter(function (type) {\r\n      return /((line)|(word)|(char))/i.test(type);\r\n    });\r\n  } // Support `position: absolute` as an alias for `absolute: true`\r\n\r\n\r\n  if (object.absolute || object.position) {\r\n    object.absolute = object.absolute || /absolute/.test(settings.position);\r\n  }\r\n\r\n  return object;\r\n}\r\n\r\n/**\r\n * Takes a list of `types` and returns an object\r\n *\r\n * @param {string | string[]} value a comma separated list of split types\r\n * @return {{lines: boolean, words: boolean, chars: boolean}}\r\n */\r\n\r\nfunction parseTypes(value) {\r\n  var types = isString(value) || isArray(value) ? String(value) : '';\r\n  return {\r\n    none: !types,\r\n    lines: /line/i.test(types),\r\n    words: /word/i.test(types),\r\n    chars: /char/i.test(types)\r\n  };\r\n}\r\n\r\n/**\r\n * Returns true if `value` is a non-null object.\r\n * @param {any} value\r\n * @return {boolean}\r\n */\r\nfunction isObject(value) {\r\n  return value !== null && typeof value === 'object';\r\n}\r\n\r\n/**\r\n * Returns true if `input` is one of the following:\r\n * - `Element`\r\n * - `Text`\r\n * - `DocumentFragment`\r\n */\r\n\r\nfunction isNode(input) {\r\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\r\n}\r\n\r\n/**\r\n * Checks if `value` is a valid array-like length.\r\n * Original source: Lodash\r\n *\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n * @example\r\n *\r\n * _.isLength(3)\r\n * // => true\r\n *\r\n * _.isLength(Number.MIN_VALUE)\r\n * // => false\r\n *\r\n * _.isLength(Infinity)\r\n * // => false\r\n *\r\n * _.isLength('3')\r\n * // => false\r\n */\r\n\r\nfunction isLength(value) {\r\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\r\n}\r\n/**\r\n * Checks if `value` is an array-like object\r\n * @param {any} value\r\n * @return {boolean} true if `value` is array-like`, else `false`\r\n * @example\r\n * isArrayLike(new Array())\r\n * // => true\r\n *\r\n * isArrayLike(document.querySelectorAll('div'))\r\n * // => true\r\n *\r\n * isArrayLike(document.getElementsByTagName('div'))\r\n * // => true\r\n *\r\n * isArrayLike(() => {})\r\n * // => false\r\n *\r\n * isArrayLike({foo: 'bar'})\r\n * // => false\r\n *\r\n * * isArrayLike(null)\r\n * // => false\r\n */\r\n\r\n\r\nfunction isArrayLike(value) {\r\n  return isObject(value) && isLength(value.length);\r\n}\r\n\r\n/**\r\n * Coerces `value` to an `Array`.\r\n *\r\n * @param {any} value\r\n * @return {any[]}\r\n * @example\r\n * // If `value` is any `Array`, returns original `Array`\r\n * let arr = [1, 2]\r\n * toArray(arr)\r\n * // => arr\r\n *\r\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\r\n * let nodeList = document.querySelectorAll('div')\r\n * toArray(nodeList)\r\n * // => HTMLElement[] s\r\n *\r\n * // If value is falsy, returns empty array\r\n * toArray(null)\r\n * // => []\r\n *\r\n * // For any other type of value, its equivalent to `Array.of(value)`\r\n * let element = document.createElement('div')\r\n * toArray(element)\r\n * // => [element]\r\n *\r\n */\r\n\r\nfunction toArray(value) {\r\n  if (isArray(value)) return value;\r\n  if (value == null) return [];\r\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\r\n}\r\n\r\n/**\r\n * Processes target elements for the splitType function.\r\n *\r\n * @param {any} target Can be one of the following:\r\n * 1. `string` - A css selector\r\n * 2. `HTMLElement` - A single element\r\n * 3. `NodeList` - A nodeList\r\n * 4. `Element[]` - An array of elements\r\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\r\n * @returns {Element[]} A flat array HTML elements\r\n * @return A flat array of elements or empty array if no elements are found\r\n */\r\n\r\nfunction getTargetElements(target) {\r\n  var elements = target; // If `target` is a selector string...\r\n\r\n  if (isString(target)) {\r\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\r\n      // If `target` is an ID, use `getElementById`\r\n      elements = document.getElementById(target.trim().slice(1));\r\n    } else {\r\n      // Else use `querySelectorAll`\r\n      elements = document.querySelectorAll(target);\r\n    }\r\n  } // Return a flattened array of elements\r\n\r\n\r\n  return toArray(elements).reduce(function (result, element) {\r\n    return [].concat(_toConsumableArray(result), _toConsumableArray(toArray(element).filter(isNode)));\r\n  }, []);\r\n}\r\n\r\nvar entries = Object.entries;\r\n\r\nvar expando = \"_splittype\";\r\nvar cache = {};\r\nvar uid = 0;\r\n/**\r\n * Stores data associated with DOM elements or other objects. This is a\r\n * simplified version of jQuery's data method.\r\n *\r\n * @signature Data(owner)\r\n * @description Get the data store object for the given owner.\r\n * @param {Object} owner the object that data will be associated with.\r\n * @return {Object} the data object for given `owner`. If no data exists\r\n *     for the given object, creates a new data store and returns it.\r\n *\r\n * @signature Data(owner, key)\r\n * @description Get the value\r\n * @param {Object} owner\r\n * @param {string} key\r\n * @return {any} the value of the provided key. If key does not exist, returns\r\n *     undefined.\r\n *\r\n * @signature Data(owner, key, value)\r\n * @description Sets the given key/value pair in data store\r\n * @param {Object} owner\r\n * @param {string} key\r\n * @param {any} value\r\n */\r\n\r\nfunction set(owner, key, value) {\r\n  if (!isObject(owner)) {\r\n    console.warn('[data.set] owner is not an object');\r\n    return null;\r\n  }\r\n\r\n  var id = owner[expando] || (owner[expando] = ++uid);\r\n  var data = cache[id] || (cache[id] = {});\r\n\r\n  if (value === undefined) {\r\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\r\n      cache[id] = _objectSpread2(_objectSpread2({}, data), key);\r\n    }\r\n  } else if (key !== undefined) {\r\n    data[key] = value;\r\n  }\r\n\r\n  return value;\r\n}\r\nfunction get(owner, key) {\r\n  var id = isObject(owner) ? owner[expando] : null;\r\n  var data = id && cache[id] || {};\r\n\r\n  if (key === undefined) {\r\n    return data;\r\n  }\r\n\r\n  return data[key];\r\n}\r\n/**\r\n * Remove all data associated with the given element\r\n */\r\n\r\nfunction remove(element) {\r\n  var id = element && element[expando];\r\n\r\n  if (id) {\r\n    delete element[id];\r\n    delete cache[id];\r\n  }\r\n}\r\n/**\r\n * Clear all cached data\r\n */\r\n\r\nfunction clear() {\r\n  Object.keys(cache).forEach(function (key) {\r\n    delete cache[key];\r\n  });\r\n}\r\n/**\r\n * Remove all temporary data from the store.\r\n */\r\n\r\nfunction cleanup() {\r\n  entries(cache).forEach(function (_ref) {\r\n    var _ref2 = _slicedToArray(_ref, 2),\r\n        id = _ref2[0],\r\n        _ref2$ = _ref2[1],\r\n        isRoot = _ref2$.isRoot,\r\n        isSplit = _ref2$.isSplit;\r\n\r\n    if (!isRoot || !isSplit) {\r\n      cache[id] = null;\r\n      delete cache[id];\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Splits a string into an array of words.\r\n *\r\n * @param {string} string\r\n * @param {string | RegExp} [separator = ' ']\r\n * @return {string[]} Array of words\r\n */\r\nfunction toWords(value) {\r\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\r\n  var string = value ? String(value) : '';\r\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\r\n}\r\n\r\n/**\r\n * Based on lodash#split <https://lodash.com/license>\r\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\r\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\r\n * Editors\r\n */\r\nvar rsAstralRange = \"\\\\ud800-\\\\udfff\";\r\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\";\r\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20f0\";\r\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\r\n/** Used to compose unicode capture groups. */\r\n\r\nvar rsAstral = \"[\".concat(rsAstralRange, \"]\");\r\nvar rsCombo = \"[\".concat(rsComboMarksRange).concat(rsComboSymbolsRange, \"]\");\r\nvar rsFitz = \"\\\\ud83c[\\\\udffb-\\\\udfff]\";\r\nvar rsModifier = \"(?:\".concat(rsCombo, \"|\").concat(rsFitz, \")\");\r\nvar rsNonAstral = \"[^\".concat(rsAstralRange, \"]\");\r\nvar rsRegional = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\";\r\nvar rsSurrPair = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\";\r\nvar rsZWJ = \"\\\\u200d\";\r\n/** Used to compose unicode regexes. */\r\n\r\nvar reOptMod = \"\".concat(rsModifier, \"?\");\r\nvar rsOptVar = \"[\".concat(rsVarRange, \"]?\");\r\nvar rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\r\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\r\nvar rsSymbol = \"(?:\".concat([\"\".concat(rsNonAstral).concat(rsCombo, \"?\"), rsCombo, rsRegional, rsSurrPair, rsAstral].join('|'), \"\\n)\");\r\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\r\n\r\nvar reUnicode = RegExp(\"\".concat(rsFitz, \"(?=\").concat(rsFitz, \")|\").concat(rsSymbol).concat(rsSeq), 'g');\r\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\r\n\r\nvar unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\r\nvar reHasUnicode = RegExp(\"[\".concat(unicodeRange.join(''), \"]\"));\r\n/**\r\n * Converts an ASCII `string` to an array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the converted array.\r\n */\r\n\r\nfunction asciiToArray(string) {\r\n  return string.split('');\r\n}\r\n/**\r\n * Checks if `string` contains Unicode symbols.\r\n *\r\n * @private\r\n * @param {string} string The string to inspect.\r\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\r\n */\r\n\r\n\r\nfunction hasUnicode(string) {\r\n  return reHasUnicode.test(string);\r\n}\r\n/**\r\n * Converts a Unicode `string` to an array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the converted array.\r\n */\r\n\r\n\r\nfunction unicodeToArray(string) {\r\n  return string.match(reUnicode) || [];\r\n}\r\n/**\r\n * Converts `string` to an array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the converted array.\r\n */\r\n\r\n\r\nfunction stringToArray(string) {\r\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\r\n}\r\n/**\r\n * Converts `value` to a string. An empty string is returned for `null`\r\n * and `undefined` values.\r\n *\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n * @example\r\n *\r\n * _.toString(null);\r\n * // => ''\r\n *\r\n * _.toString([1, 2, 3]);\r\n * // => '1,2,3'\r\n */\r\n\r\nfunction toString(value) {\r\n  return value == null ? '' : String(value);\r\n}\r\n/**\r\n * Splits `string` into an array of characters. If `separator` is omitted,\r\n * it behaves likes split.split('').\r\n *\r\n * Unlike native string.split(''), it can split strings that contain unicode\r\n * characters like emojis and symbols.\r\n *\r\n * @param {string} [string=''] The string to split.\r\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\r\n * @returns {Array} Returns the string segments.\r\n * @example\r\n * toChars('foo');\r\n * // => ['f', 'o', 'o']\r\n *\r\n * toChars('foo bar');\r\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\r\n *\r\n * toChars('f😀o');\r\n * // => ['f', '😀', 'o']\r\n *\r\n * toChars('f-😀-o', /-/);\r\n * // => ['f', '😀', 'o']\r\n *\r\n */\r\n\r\n\r\nfunction toChars(string) {\r\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\r\n  string = toString(string);\r\n\r\n  if (string && isString(string)) {\r\n    if (!separator && hasUnicode(string)) {\r\n      return stringToArray(string);\r\n    }\r\n  }\r\n\r\n  return string.split(separator);\r\n}\r\n\r\n/**\r\n * Create an HTML element with the the given attributes\r\n *\r\n * attributes can include standard HTML attribute, as well as the following\r\n * \"special\" properties:\r\n *   - children: HTMLElement | ArrayLike<HTMLElement>\r\n *   - textContent: string\r\n *   - innerHTML: string\r\n *\r\n * @param {string} name\r\n * @param  {Object} [attributes]\r\n * @returns {HTMLElement}\r\n */\r\n\r\nfunction createElement(name, attributes) {\r\n  var element = document.createElement(name);\r\n\r\n  if (!attributes) {\r\n    // When called without the second argument, its just return the result\r\n    // of `document.createElement`\r\n    return element;\r\n  }\r\n\r\n  Object.keys(attributes).forEach(function (attribute) {\r\n    var rawValue = attributes[attribute];\r\n    var value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\r\n\r\n    if (value === null || value === '') return;\r\n\r\n    if (attribute === 'children') {\r\n      // Children can be one or more Elements or DOM strings\r\n      element.append.apply(element, _toConsumableArray(toArray(value)));\r\n    } else {\r\n      // Handle standard HTML attributes\r\n      element.setAttribute(attribute, value);\r\n    }\r\n  });\r\n  return element;\r\n}\r\n\r\nvar defaults = {\r\n  splitClass: '',\r\n  lineClass: 'line',\r\n  wordClass: 'word',\r\n  charClass: 'char',\r\n  types: ['lines', 'words', 'chars'],\r\n  absolute: false,\r\n  tagName: 'div'\r\n};\r\n\r\n/**\r\n * Splits the text content of a single TextNode into words and/or characters.\r\n *\r\n * This functions gets called for every text node inside the target element. It\r\n * replaces the text node with a document fragment containing the split text.\r\n * Returns an array of the split word and character elements from this node.\r\n *\r\n * @param {TextNode} textNode\r\n * @param {Object} settings\r\n * @return {{words: Element[], chars: Element[]}}\r\n */\r\n\r\nfunction splitWordsAndChars(textNode, settings) {\r\n  settings = extend(defaults, settings); // The split types\r\n\r\n  var types = parseTypes(settings.types); // the tag name for split text nodes\r\n\r\n  var TAG_NAME = settings.tagName; // value of the text node\r\n\r\n  var VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\r\n\r\n  var splitText = document.createDocumentFragment(); // Arrays of split word and character elements\r\n\r\n  var words = [];\r\n  var chars = [];\r\n\r\n  if (/^\\s/.test(VALUE)) {\r\n    splitText.append(' ');\r\n  } // Create an array of wrapped word elements.\r\n\r\n\r\n  words = toWords(VALUE).reduce(function (result, WORD, idx, arr) {\r\n    // Let `wordElement` be the wrapped element for the current word\r\n    var wordElement;\r\n    var characterElementsForCurrentWord; // -> If splitting text into characters...\r\n\r\n    if (types.chars) {\r\n      // Iterate through the characters in the current word\r\n      characterElementsForCurrentWord = toChars(WORD).map(function (CHAR) {\r\n        var characterElement = createElement(TAG_NAME, {\r\n          \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\r\n          style: 'display: inline-block;',\r\n          children: CHAR\r\n        });\r\n        set(characterElement, 'isChar', true);\r\n        chars = [].concat(_toConsumableArray(chars), [characterElement]);\r\n        return characterElement;\r\n      });\r\n    } // END IF;\r\n\r\n\r\n    if (types.words || types.lines) {\r\n      // -> If Splitting Text Into Words...\r\n      //    Create an element to wrap the current word. If we are also\r\n      //    splitting text into characters, the word element will contain the\r\n      //    wrapped character nodes for this word. If not, it will contain the\r\n      //    plain text content (WORD)\r\n      wordElement = createElement(TAG_NAME, {\r\n        \"class\": \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\r\n        style: \"display: inline-block; \".concat(types.words && settings.absolute ? \"position: relative;\" : ''),\r\n        children: types.chars ? characterElementsForCurrentWord : WORD\r\n      });\r\n      set(wordElement, {\r\n        isWord: true,\r\n        isWordStart: true,\r\n        isWordEnd: true\r\n      });\r\n      splitText.appendChild(wordElement);\r\n    } else {\r\n      // -> If NOT splitting into words OR lines...\r\n      //    Append the characters elements directly to splitText.\r\n      characterElementsForCurrentWord.forEach(function (characterElement) {\r\n        splitText.appendChild(characterElement);\r\n      });\r\n    }\r\n\r\n    if (idx < arr.length - 1) {\r\n      // Add a space after the word.\r\n      splitText.append(' ');\r\n    } // If not splitting text into words, we return an empty array\r\n\r\n\r\n    return types.words ? result.concat(wordElement) : result;\r\n  }, []); // END LOOP;\r\n  // Add a trailing white space to maintain word spacing\r\n\r\n  if (/\\s$/.test(VALUE)) {\r\n    splitText.append(' ');\r\n  }\r\n\r\n  textNode.replaceWith(splitText);\r\n  return {\r\n    words: words,\r\n    chars: chars\r\n  };\r\n}\r\n\r\n/**\r\n * Splits the text content of a target element into words and/or characters.\r\n * The function is recursive, it will also split the text content of any child\r\n * elements into words/characters, while preserving the nested elements.\r\n *\r\n * @param {Node} node an HTML Element or Text Node\r\n * @param {Object} setting splitType settings\r\n */\r\n\r\nfunction split(node, settings) {\r\n  var type = node.nodeType; // Arrays of split words and characters\r\n\r\n  var wordsAndChars = {\r\n    words: [],\r\n    chars: []\r\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\r\n\r\n  if (!/(1|3|11)/.test(type)) {\r\n    return wordsAndChars;\r\n  } // A) IF `node` is TextNode that contains characters other than white space...\r\n  //    Split the text content of the node into words and/or characters\r\n  //    return an object containing the split word and character elements\r\n\r\n\r\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\r\n    return splitWordsAndChars(node, settings);\r\n  } // B) ELSE `node` is an 'Element'\r\n  //    Iterate through its child nodes, calling the `split` function\r\n  //    recursively for each child node.\r\n\r\n\r\n  var childNodes = toArray(node.childNodes);\r\n\r\n  if (childNodes.length) {\r\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\r\n\r\n    if (!get(node).isRoot) {\r\n      node.style.display = 'inline-block';\r\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\r\n      // splitting text into lines, we need to check if the element should\r\n      // have a space before and after, and store that value for later.\r\n      // Note: this was necessary to maintain the correct spacing when nested\r\n      // elements do not align with word boundaries. For example, a nested\r\n      // element only wraps part of a word.\r\n\r\n      var nextSibling = node.nextSibling;\r\n      var prevSibling = node.previousSibling;\r\n      var text = node.textContent || '';\r\n      var textAfter = nextSibling ? nextSibling.textContent : ' ';\r\n      var textBefore = prevSibling ? prevSibling.textContent : ' ';\r\n      set(node, {\r\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\r\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\r\n      });\r\n    }\r\n  } // Iterate through child nodes, calling `split` recursively\r\n  // Returns an object containing all split words and chars\r\n\r\n\r\n  return childNodes.reduce(function (result, child) {\r\n    var _split = split(child, settings),\r\n        words = _split.words,\r\n        chars = _split.chars;\r\n\r\n    return {\r\n      words: [].concat(_toConsumableArray(result.words), _toConsumableArray(words)),\r\n      chars: [].concat(_toConsumableArray(result.chars), _toConsumableArray(chars))\r\n    };\r\n  }, wordsAndChars);\r\n}\r\n\r\n/**\r\n * Gets the height and position of an element relative to offset parent.\r\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\r\n * precision.\r\n *\r\n * TODO needs work\r\n */\r\nfunction getPosition(node, isWord, settings, scrollPos) {\r\n  if (!settings.absolute) {\r\n    return {\r\n      top: isWord ? node.offsetTop : null\r\n    };\r\n  }\r\n\r\n  var parent = node.offsetParent;\r\n\r\n  var _scrollPos = _slicedToArray(scrollPos, 2),\r\n      scrollX = _scrollPos[0],\r\n      scrollY = _scrollPos[1];\r\n\r\n  var parentX = 0;\r\n  var parentY = 0;\r\n\r\n  if (parent && parent !== document.body) {\r\n    var parentRect = parent.getBoundingClientRect();\r\n    parentX = parentRect.x + scrollX;\r\n    parentY = parentRect.y + scrollY;\r\n  }\r\n\r\n  var _node$getBoundingClie = node.getBoundingClientRect(),\r\n      width = _node$getBoundingClie.width,\r\n      height = _node$getBoundingClie.height,\r\n      x = _node$getBoundingClie.x,\r\n      y = _node$getBoundingClie.y;\r\n\r\n  var top = y + scrollY - parentY;\r\n  var left = x + scrollX - parentX;\r\n  return {\r\n    width: width,\r\n    height: height,\r\n    top: top,\r\n    left: left\r\n  };\r\n}\r\n\r\n/**\r\n * Recursively \"un-splits\" text into words.\r\n * This is used when splitting text into lines but not words.\r\n * We initially split the text into words so we can maintain the correct line\r\n * breaks. Once text has been split into lines, we \"un-split\" the words...\r\n * @param {Element}\r\n * @return {void}\r\n */\r\n\r\nfunction unSplitWords(element) {\r\n  if (!get(element).isWord) {\r\n    toArray(element.children).forEach(function (child) {\r\n      return unSplitWords(child);\r\n    });\r\n  } else {\r\n    remove(element);\r\n    element.replaceWith.apply(element, _toConsumableArray(element.childNodes));\r\n  }\r\n}\r\n\r\nvar createFragment = function createFragment() {\r\n  return document.createDocumentFragment();\r\n};\r\n\r\nfunction repositionAfterSplit(element, settings, scrollPos) {\r\n  var types = parseTypes(settings.types);\r\n  var TAG_NAME = settings.tagName;\r\n  var nodes = element.getElementsByTagName('*');\r\n  var wordsInEachLine = [];\r\n  var wordsInCurrentLine = [];\r\n  var lineOffsetY = null;\r\n  var elementHeight;\r\n  var elementWidth;\r\n  var contentBox;\r\n  var lines = [];\r\n  /**------------------------------------------------\r\n   ** GET STYLES AND POSITIONS\r\n   **-----------------------------------------------*/\r\n  // There is no built-in way to detect natural line breaks in text (when a\r\n  // block of text wraps to fit its container). To split text into lines, we\r\n  // have to detect line breaks by checking the top offset of words. This is\r\n  // why text was split into words first. To apply absolute\r\n  // positioning, its also necessary to record the size and position of every\r\n  // split node (lines, words, characters).\r\n  // To consolidate DOM getting/settings, this is all done at the same time,\r\n  // before actually splitting text into lines, which involves restructuring\r\n  // the DOM again.\r\n  // Cache the element's parent and next sibling (for DOM removal).\r\n\r\n  var parent = element.parentElement;\r\n  var nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\r\n\r\n  var splitText = createFragment(); // get the computed style object for the element\r\n\r\n  var cs = window.getComputedStyle(element);\r\n  var align = cs.textAlign;\r\n  var fontSize = parseFloat(cs.fontSize);\r\n  var lineThreshold = fontSize * 0.2; // IF using absolute position...\r\n\r\n  if (settings.absolute) {\r\n    // Let contentBox be an object containing the width and offset position of\r\n    // the element's content box (the area inside padding box). This is needed\r\n    // (for absolute positioning) to set the width and position of line\r\n    // elements, which have not been created yet.\r\n    contentBox = {\r\n      left: element.offsetLeft,\r\n      top: element.offsetTop,\r\n      width: element.offsetWidth\r\n    }; // Let elementWidth and elementHeight be the actual width/height of the\r\n    // element. Also check if the element has inline height or width styles\r\n    // already set. If it does, cache those values for later.\r\n\r\n    elementWidth = element.offsetWidth;\r\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\r\n\r\n    set(element, {\r\n      cssWidth: element.style.width,\r\n      cssHeight: element.style.height\r\n    });\r\n  } // Iterate over every node in the target element\r\n\r\n\r\n  toArray(nodes).forEach(function (node) {\r\n    // node is a word element or custom html element\r\n    var isWordLike = node.parentElement === element; // TODO needs work\r\n    // Get te size and position of split text nodes\r\n\r\n    var _getPosition = getPosition(node, isWordLike, settings, scrollPos),\r\n        width = _getPosition.width,\r\n        height = _getPosition.height,\r\n        top = _getPosition.top,\r\n        left = _getPosition.left; // If element is a `<br>` tag return here\r\n\r\n\r\n    if (/^br$/i.test(node.nodeName)) return;\r\n\r\n    if (types.lines && isWordLike) {\r\n      // We compare the top offset of the current word to the top offset of\r\n      // previous words on the current line. If the difference is greater than\r\n      // our defined threshold (20%), we assume this word is on a new line.\r\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\r\n        lineOffsetY = top;\r\n        wordsInEachLine.push(wordsInCurrentLine = []);\r\n      } // Add the current word node to the line array\r\n\r\n\r\n      wordsInCurrentLine.push(node);\r\n    } // END IF\r\n\r\n\r\n    if (settings.absolute) {\r\n      // Store the size and position split text nodes\r\n      set(node, {\r\n        top: top,\r\n        left: left,\r\n        width: width,\r\n        height: height\r\n      });\r\n    }\r\n  }); // END LOOP\r\n  // Remove the element from the DOM\r\n\r\n  if (parent) {\r\n    parent.removeChild(element);\r\n  }\r\n  /**------------------------------------------------\r\n   ** SPLIT LINES\r\n   **-----------------------------------------------*/\r\n\r\n\r\n  if (types.lines) {\r\n    // Iterate over lines of text (see 11 b)\r\n    // Let `line` be the array of words in the current line.\r\n    // Return an array of the wrapped line elements (lineElements)\r\n    lines = wordsInEachLine.map(function (wordsInThisLine) {\r\n      // Create an element to wrap the current line.\r\n      var lineElement = createElement(TAG_NAME, {\r\n        \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\r\n        style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\r\n      });\r\n      set(lineElement, 'isLine', true);\r\n      var lineDimensions = {\r\n        height: 0,\r\n        top: 1e4\r\n      }; // Append the `lineElement` to `container`\r\n\r\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\r\n      // Note: wordOrElement can either be a word node or nested element\r\n\r\n      wordsInThisLine.forEach(function (wordOrElement, idx, arr) {\r\n        var _data$get = get(wordOrElement),\r\n            isWordEnd = _data$get.isWordEnd,\r\n            top = _data$get.top,\r\n            height = _data$get.height;\r\n\r\n        var next = arr[idx + 1]; // Determine line height / y-position\r\n        // we use the height and offsetTop of the words which we already\r\n        // recorded. Because custom nested elements could have their own\r\n        // styles, the words on a line may not all be the same height or\r\n        // y position. So we take the greatest height / y - offset of the\r\n        // words on this line.\r\n\r\n        lineDimensions.height = Math.max(lineDimensions.height, height);\r\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\r\n\r\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\r\n        // If this is not the last word on the current line.\r\n        // TODO - logic for handing spacing can be improved\r\n\r\n        if (isWordEnd && get(next).isWordStart) {\r\n          lineElement.append(' ');\r\n        }\r\n      }); // END LOOP\r\n\r\n      if (settings.absolute) {\r\n        set(lineElement, {\r\n          height: lineDimensions.height,\r\n          top: lineDimensions.top\r\n        });\r\n      }\r\n\r\n      return lineElement;\r\n    }); // END LOOP\r\n\r\n    if (!types.words) {\r\n      unSplitWords(splitText);\r\n    } // 10. Insert the new container\r\n\r\n\r\n    element.replaceChildren(splitText);\r\n  }\r\n  /**------------------------------------------------\r\n   **  SET ABSOLUTE POSITION\r\n   **-----------------------------------------------*/\r\n  // Apply absolute positioning to all child elements of the target element.\r\n  // This includes split lines, words, chars, and custom HTML elements that were\r\n  // included by the user. The size and position of child elements has already\r\n  // been recorded before splitting text into lines.\r\n\r\n\r\n  if (settings.absolute) {\r\n    // Set the width/height of the parent element so it does not collapse\r\n    // when its children are set to absolute position.\r\n    element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\r\n    element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all child elements\r\n\r\n    toArray(nodes).forEach(function (node) {\r\n      var _data$get2 = get(node),\r\n          isLine = _data$get2.isLine,\r\n          top = _data$get2.top,\r\n          left = _data$get2.left,\r\n          width = _data$get2.width,\r\n          height = _data$get2.height;\r\n\r\n      var parentData = get(node.parentElement);\r\n      var isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\r\n      // -> If `node` a line element, we use the top offset of its first child\r\n      // -> If `node` the child of line element, then its top offset is zero\r\n\r\n      node.style.top = \"\".concat(isChildOfLineNode ? top - parentData.top : top, \"px\"); // Set the left position of the current node.\r\n      // -> IF `node` is a line element, this is equal to the position left of\r\n      //    the content box of the parent element\r\n      // -> IF `node` is the child of a line element, the value has to adjusted\r\n      //    so its relative to the line element\r\n\r\n      node.style.left = isLine ? \"\".concat(contentBox.left, \"px\") : \"\".concat(left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\r\n\r\n      node.style.height = \"\".concat(height, \"px\"); //  Set the width of the current node.\r\n      //  If its a line element, width is equal to the width of the contentBox.\r\n\r\n      node.style.width = isLine ? \"\".concat(contentBox.width, \"px\") : \"\".concat(width, \"px\"); // Finally, set the node's position to absolute.\r\n\r\n      node.style.position = 'absolute';\r\n    });\r\n  } // end if;\r\n  // 14. Re-attach the element to the DOM\r\n\r\n\r\n  if (parent) {\r\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\r\n  }\r\n\r\n  return lines;\r\n}\r\n\r\nvar _defaults = extend(defaults, {});\r\n\r\nvar SplitType = /*#__PURE__*/function () {\r\n  _createClass(SplitType, null, [{\r\n    key: \"clearData\",\r\n\r\n    /**\r\n     * CLears all data\r\n     */\r\n    value: function clearData() {\r\n      clear();\r\n    }\r\n    /**\r\n     * The default settings for all splitType instances\r\n     * @static\r\n     */\r\n\r\n  }, {\r\n    key: \"setDefaults\",\r\n\r\n    /**\r\n     * Sets the default settings for all SplitType instances.\r\n     * The provided object will be merged with the existing defaults objects.\r\n     *\r\n     * @param {Object} settings an object containing the settings to override\r\n     * @returns {Object} the new default settings\r\n     * @public\r\n     * @static\r\n     * @example\r\n     * SplitType.setDefaults({ \"position\": \"absolute\" })\r\n     */\r\n    value: function setDefaults(options) {\r\n      _defaults = extend(_defaults, parseSettings(options));\r\n      return defaults;\r\n    }\r\n    /**\r\n     * Revert target elements to their original html content\r\n     * Has no effect on that\r\n     *\r\n     * @param {any} elements The target elements to revert. One of:\r\n     *  - {string} A css selector\r\n     *  - {HTMLElement} A single element\r\n     * -  {NodeList} A NodeList or collection\r\n     *  - {HTMLElement[]} An array of Elements\r\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\r\n     * @static\r\n     */\r\n\r\n  }, {\r\n    key: \"revert\",\r\n    value: function revert(elements) {\r\n      getTargetElements(elements).forEach(function (element) {\r\n        var _data$get = get(element),\r\n            isSplit = _data$get.isSplit,\r\n            html = _data$get.html,\r\n            cssWidth = _data$get.cssWidth,\r\n            cssHeight = _data$get.cssHeight;\r\n\r\n        if (isSplit) {\r\n          element.innerHTML = html;\r\n          element.style.width = cssWidth || '';\r\n          element.style.height = cssHeight || '';\r\n          remove(element);\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Creates a new SplitType instance\r\n     * This static method provides a way to create a `SplitType` instance without\r\n     * using the `new` keyword.\r\n     *\r\n     * @param {any} target The target elements to split. One of:\r\n     *  - {string} A css selector\r\n     *  - {HTMLElement} A single element\r\n     * -  {NodeList} A NodeList or collection\r\n     *  - {HTMLElement[]} An array of Elements\r\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\r\n     * @param {Object} [options] Settings for the SplitType instance\r\n     * @return {SplitType} the SplitType instance\r\n     * @static\r\n     */\r\n\r\n  }, {\r\n    key: \"create\",\r\n    value: function create(target, options) {\r\n      return new SplitType(target, options);\r\n    }\r\n    /**\r\n     * Creates a new `SplitType` instance\r\n     *\r\n     * @param {any} elements The target elements to split. One of:\r\n     *  - {string} A css selector\r\n     *  - {HTMLElement} A single element\r\n     * -  {NodeList} A NodeList or collection\r\n     *  - {HTMLElement[]} An array of Elements\r\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\r\n     * @param {Object} [options] Settings for the SplitType instance\r\n     */\r\n\r\n  }, {\r\n    key: \"data\",\r\n\r\n    /**\r\n     * The internal data store\r\n     */\r\n    get: function get() {\r\n      return cache;\r\n    }\r\n  }, {\r\n    key: \"defaults\",\r\n    get: function get() {\r\n      return _defaults;\r\n    }\r\n    /**\r\n     * Sets the default settings for all SplitType instances.\r\n     *\r\n     * Setting `SplitType.defaults` to an object will merge that object with the\r\n     * existing defaults.\r\n     *\r\n     * @param {Object} settings an object containing the settings to override\r\n     * @deprecated\r\n     * @static\r\n     * @example\r\n     * SplitType.defaults = { \"position\": \"absolute\" }\r\n     */\r\n    ,\r\n    set: function set(options) {\r\n      _defaults = extend(_defaults, parseSettings(options));\r\n    }\r\n  }]);\r\n\r\n  function SplitType(elements, options) {\r\n    _classCallCheck(this, SplitType);\r\n\r\n    this.isSplit = false;\r\n    this.settings = extend(_defaults, parseSettings(options));\r\n    this.elements = getTargetElements(elements); // Start the split process\r\n\r\n    this.split();\r\n  }\r\n  /**\r\n   * Splits the text in all target elements. This method is called\r\n   * automatically when a new SplitType instance is created. It can also be\r\n   * called manually to re-split text with new options.\r\n   * @param {Object} options\r\n   * @public\r\n   */\r\n\r\n\r\n  _createClass(SplitType, [{\r\n    key: \"split\",\r\n    value: function split$1(options) {\r\n      var _this = this;\r\n\r\n      // Revert target elements (if they are already split)\r\n      // Note: revert was already called once in the constructor. However, we\r\n      // need to call it again here so text is reverted when the user manually\r\n      // calls the `split` method to re-split text.\r\n      this.revert(); // Store the original html content of each target element\r\n\r\n      this.elements.forEach(function (element) {\r\n        set(element, 'html', element.innerHTML);\r\n      }); // Create arrays to hold the split lines, words, and characters\r\n\r\n      this.lines = [];\r\n      this.words = [];\r\n      this.chars = []; // cache vertical scroll position before splitting\r\n\r\n      var scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\r\n\r\n      if (options !== undefined) {\r\n        this.settings = extend(this.settings, parseSettings(options));\r\n      }\r\n\r\n      var types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\r\n      // @example new SplitType('#target', { types: [] })\r\n\r\n      if (types.none) {\r\n        return;\r\n      } // Split text in each target element\r\n\r\n\r\n      this.elements.forEach(function (element) {\r\n        // Add the split text nodes from this element to the arrays of all split\r\n        // text nodes for this instance.\r\n        set(element, 'isRoot', true);\r\n\r\n        var _split2 = split(element, _this.settings),\r\n            words = _split2.words,\r\n            chars = _split2.chars;\r\n\r\n        _this.words = [].concat(_toConsumableArray(_this.words), _toConsumableArray(words));\r\n        _this.chars = [].concat(_toConsumableArray(_this.chars), _toConsumableArray(chars));\r\n      });\r\n      this.elements.forEach(function (element) {\r\n        if (types.lines || _this.settings.absolute) {\r\n          var lines = repositionAfterSplit(element, _this.settings, scrollPos);\r\n          _this.lines = [].concat(_toConsumableArray(_this.lines), _toConsumableArray(lines));\r\n        }\r\n      }); // Set isSplit to true for the SplitType instance\r\n\r\n      this.isSplit = true; // Set scroll position to cached value.\r\n\r\n      window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\r\n\r\n      cleanup();\r\n    }\r\n    /**\r\n     * Reverts target element(s) back to their original html content\r\n     * Deletes all stored data associated with the target elements\r\n     * Resets the properties on the splitType instance\r\n     *\r\n     * @public\r\n     */\r\n\r\n  }, {\r\n    key: \"revert\",\r\n    value: function revert() {\r\n      if (this.isSplit) {\r\n        // Reset instance properties if necessary\r\n        this.lines = null;\r\n        this.words = null;\r\n        this.chars = null;\r\n        this.isSplit = false;\r\n      }\r\n\r\n      SplitType.revert(this.elements);\r\n    }\r\n  }]);\r\n\r\n  return SplitType;\r\n}();\r\n\r\nexport { SplitType as default };\r\n"],
  "mappings": "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",
  "names": ["createFragment", "SplitType", "get", "set"]
}
